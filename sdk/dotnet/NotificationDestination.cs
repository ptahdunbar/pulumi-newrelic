// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.NewRelic
{
    /// <summary>
    /// Use this resource to create and manage New Relic notification destinations. Details regarding supported products and permissions can be found [here](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/destinations).
    /// 
    /// ## Example Usage
    /// 
    /// ##### [Webhook](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#webhook)
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.NotificationDestination("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         AuthBasic = new NewRelic.Inputs.NotificationDestinationAuthBasicArgs
    ///         {
    ///             Password = "password",
    ///             User = "username",
    ///         },
    ///         Properties = new[]
    ///         {
    ///             new NewRelic.Inputs.NotificationDestinationPropertyArgs
    ///             {
    ///                 Key = "url",
    ///                 Value = "https://webhook.site/",
    ///             },
    ///         },
    ///         Type = "WEBHOOK",
    ///     });
    /// 
    /// });
    /// ```
    /// See additional examples.
    /// ## Additional Examples
    /// 
    /// ##### [ServiceNow](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#servicenow)
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.NotificationDestination("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         AuthBasic = new NewRelic.Inputs.NotificationDestinationAuthBasicArgs
    ///         {
    ///             Password = "password",
    ///             User = "username",
    ///         },
    ///         Properties = new[]
    ///         {
    ///             new NewRelic.Inputs.NotificationDestinationPropertyArgs
    ///             {
    ///                 Key = "url",
    ///                 Value = "https://service-now.com/",
    ///             },
    ///             new NewRelic.Inputs.NotificationDestinationPropertyArgs
    ///             {
    ///                 Key = "two_way_integration",
    ///                 Value = "true",
    ///             },
    ///         },
    ///         Type = "SERVICE_NOW",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ##### [Email](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#email)
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.NotificationDestination("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         Properties = new[]
    ///         {
    ///             new NewRelic.Inputs.NotificationDestinationPropertyArgs
    ///             {
    ///                 Key = "email",
    ///                 Value = "email@email.com,email2@email.com",
    ///             },
    ///         },
    ///         Type = "EMAIL",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ##### [Jira](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#jira)
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.NotificationDestination("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         AuthBasic = new NewRelic.Inputs.NotificationDestinationAuthBasicArgs
    ///         {
    ///             Password = "password",
    ///             User = "example@email.com",
    ///         },
    ///         Properties = new[]
    ///         {
    ///             new NewRelic.Inputs.NotificationDestinationPropertyArgs
    ///             {
    ///                 Key = "url",
    ///                 Value = "https://example.atlassian.net",
    ///             },
    ///         },
    ///         Type = "JIRA",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ##### [PagerDuty with service integration](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#pagerduty-sli)
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.NotificationDestination("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         AuthToken = new NewRelic.Inputs.NotificationDestinationAuthTokenArgs
    ///         {
    ///             Prefix = "Token token=",
    ///             Token = "10567a689d984d03c021034b22a789e2",
    ///         },
    ///         Type = "PAGERDUTY_SERVICE_INTEGRATION",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ##### [PagerDuty with account integration](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#pagerduty-ali)
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.NotificationDestination("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         AuthToken = new NewRelic.Inputs.NotificationDestinationAuthTokenArgs
    ///         {
    ///             Prefix = "Token token=",
    ///             Token = "u+E8EU3MhsZwLfZ1ic1A",
    ///         },
    ///         Properties = new[]
    ///         {
    ///             new NewRelic.Inputs.NotificationDestinationPropertyArgs
    ///             {
    ///                 Key = "two_way_integration",
    ///                 Value = "true",
    ///             },
    ///         },
    ///         Type = "PAGERDUTY_ACCOUNT_INTEGRATION",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// &gt; **NOTE:** Sensitive data such as destination API keys, service keys, auth object, etc are not returned from the underlying API for security reasons and may not be set in state when importing.
    /// 
    /// ## Additional Information
    /// 
    /// More information about destinations integrations can be found in NewRelic [documentation](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/).
    /// More details about the destinations API can be found [here](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations).
    /// </summary>
    [NewRelicResourceType("newrelic:index/notificationDestination:NotificationDestination")]
    public partial class NotificationDestination : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
        /// </summary>
        [Output("accountId")]
        public Output<int> AccountId { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the destination is active.
        /// </summary>
        [Output("active")]
        public Output<bool?> Active { get; private set; } = null!;

        /// <summary>
        /// A nested block that describes a basic username and password authentication credentials. Only one auth_basic block is permitted per notification destination definition.  See Nested auth_basic blocks below for details.
        /// </summary>
        [Output("authBasic")]
        public Output<Outputs.NotificationDestinationAuthBasic?> AuthBasic { get; private set; } = null!;

        /// <summary>
        /// A nested block that describes a token authentication credentials. Only one auth_token block is permitted per notification destination definition.  See Nested auth_token blocks below for details.
        /// </summary>
        [Output("authToken")]
        public Output<Outputs.NotificationDestinationAuthToken?> AuthToken { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the user is authenticated with the destination.
        /// </summary>
        [Output("isUserAuthenticated")]
        public Output<bool> IsUserAuthenticated { get; private set; } = null!;

        /// <summary>
        /// The last time a notification was sent.
        /// </summary>
        [Output("lastSent")]
        public Output<string> LastSent { get; private set; } = null!;

        /// <summary>
        /// The name of the destination.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// A nested block that describes a notification destination property. See Nested property blocks below for details.
        /// </summary>
        [Output("properties")]
        public Output<ImmutableArray<Outputs.NotificationDestinationProperty>> Properties { get; private set; } = null!;

        /// <summary>
        /// The status of the destination.
        /// </summary>
        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        /// <summary>
        /// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `WEBHOOK`, `JIRA`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`.
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;


        /// <summary>
        /// Create a NotificationDestination resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public NotificationDestination(string name, NotificationDestinationArgs args, CustomResourceOptions? options = null)
            : base("newrelic:index/notificationDestination:NotificationDestination", name, args ?? new NotificationDestinationArgs(), MakeResourceOptions(options, ""))
        {
        }

        private NotificationDestination(string name, Input<string> id, NotificationDestinationState? state = null, CustomResourceOptions? options = null)
            : base("newrelic:index/notificationDestination:NotificationDestination", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing NotificationDestination resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static NotificationDestination Get(string name, Input<string> id, NotificationDestinationState? state = null, CustomResourceOptions? options = null)
        {
            return new NotificationDestination(name, id, state, options);
        }
    }

    public sealed class NotificationDestinationArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
        /// </summary>
        [Input("accountId")]
        public Input<int>? AccountId { get; set; }

        /// <summary>
        /// Indicates whether the destination is active.
        /// </summary>
        [Input("active")]
        public Input<bool>? Active { get; set; }

        /// <summary>
        /// A nested block that describes a basic username and password authentication credentials. Only one auth_basic block is permitted per notification destination definition.  See Nested auth_basic blocks below for details.
        /// </summary>
        [Input("authBasic")]
        public Input<Inputs.NotificationDestinationAuthBasicArgs>? AuthBasic { get; set; }

        /// <summary>
        /// A nested block that describes a token authentication credentials. Only one auth_token block is permitted per notification destination definition.  See Nested auth_token blocks below for details.
        /// </summary>
        [Input("authToken")]
        public Input<Inputs.NotificationDestinationAuthTokenArgs>? AuthToken { get; set; }

        /// <summary>
        /// The name of the destination.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("properties", required: true)]
        private InputList<Inputs.NotificationDestinationPropertyArgs>? _properties;

        /// <summary>
        /// A nested block that describes a notification destination property. See Nested property blocks below for details.
        /// </summary>
        public InputList<Inputs.NotificationDestinationPropertyArgs> Properties
        {
            get => _properties ?? (_properties = new InputList<Inputs.NotificationDestinationPropertyArgs>());
            set => _properties = value;
        }

        /// <summary>
        /// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `WEBHOOK`, `JIRA`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public NotificationDestinationArgs()
        {
        }
        public static new NotificationDestinationArgs Empty => new NotificationDestinationArgs();
    }

    public sealed class NotificationDestinationState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
        /// </summary>
        [Input("accountId")]
        public Input<int>? AccountId { get; set; }

        /// <summary>
        /// Indicates whether the destination is active.
        /// </summary>
        [Input("active")]
        public Input<bool>? Active { get; set; }

        /// <summary>
        /// A nested block that describes a basic username and password authentication credentials. Only one auth_basic block is permitted per notification destination definition.  See Nested auth_basic blocks below for details.
        /// </summary>
        [Input("authBasic")]
        public Input<Inputs.NotificationDestinationAuthBasicGetArgs>? AuthBasic { get; set; }

        /// <summary>
        /// A nested block that describes a token authentication credentials. Only one auth_token block is permitted per notification destination definition.  See Nested auth_token blocks below for details.
        /// </summary>
        [Input("authToken")]
        public Input<Inputs.NotificationDestinationAuthTokenGetArgs>? AuthToken { get; set; }

        /// <summary>
        /// Indicates whether the user is authenticated with the destination.
        /// </summary>
        [Input("isUserAuthenticated")]
        public Input<bool>? IsUserAuthenticated { get; set; }

        /// <summary>
        /// The last time a notification was sent.
        /// </summary>
        [Input("lastSent")]
        public Input<string>? LastSent { get; set; }

        /// <summary>
        /// The name of the destination.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("properties")]
        private InputList<Inputs.NotificationDestinationPropertyGetArgs>? _properties;

        /// <summary>
        /// A nested block that describes a notification destination property. See Nested property blocks below for details.
        /// </summary>
        public InputList<Inputs.NotificationDestinationPropertyGetArgs> Properties
        {
            get => _properties ?? (_properties = new InputList<Inputs.NotificationDestinationPropertyGetArgs>());
            set => _properties = value;
        }

        /// <summary>
        /// The status of the destination.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `WEBHOOK`, `JIRA`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public NotificationDestinationState()
        {
        }
        public static new NotificationDestinationState Empty => new NotificationDestinationState();
    }
}
